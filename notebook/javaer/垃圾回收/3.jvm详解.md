# jvm 详解

## 一、hotspat 的实现

### 1、oop(Ordinary Object Pointer)/klass

![avatar](./img/oop-klass.png)

### 2、instanceOopDesc 与 instanceKlass

![avatar](./img/mem-area.jpg)

### 3、JVM 中，InstanceKlass、java.lang.Class 的关系

- ClassFileParser 将 class 文件在 runtime 解析成一个个 InstanceKlass 对象，这个对象是静态字节码文件在运行时 Metaspace 空间的一个映射。我们知道 Java 是一种支持反射的语言，为了能在 Java 层实现对定义类型的解构，JVM 实现了 InstanceKlass 的一个 java mirror 的概念——java.lang.Class 对象。
  InstanceKlass 类继承自 Klass 类，在 Klass 类中有一个成员变量，并且提供了相应的 Setter/Getter 函数实现：

  ```java mirror
  // java/lang/Class instance mirroring this class
  oop       _java_mirror;
  oop java_mirror() const              { return _java_mirror; }
  void set_java_mirror(oop m) { klass_oop_store(&_java_mirror, m); }
  ```

### 4、反射

- Class 类所提供的反射机制，最终都是通过 JNI 接口，调用相应的 native 方法，然后通过 as_Klass 函数转换成 InstanceKlass 对象,拿到定义类型的元数据信息的。

- 在 java_lang_Class 类中，也提供了 Class 对象与 Klass 对象的转化函数：

  ```java_lang_Class
  static Klass* as_Klass(oop java_class);
  static void set_klass(oop java_class, Klass* klass);
  ```

### 5、方法调用

- java 是一种半编译半解释型语言，也就是 class 文件会被解释成机器码，而方法调用也会被解释成具体的方法调用指令，大致可以分为以下五类指令：

  - invokestatic：调用静态方法；
  - invokespecial：调用实例构造方法，私有方法和父类方法；
  - invokevirtual：调用虚方法；
  - invokeinterface：调用接口方法，在运行时再确定一个实现此接口的对象；
  - invokedynamic：在运行时动态解析出调用点限定符所引用的方法之后，调用该方法；
    - 注意：invokedynamic 指令是 jdk1.7 才加入的，但是在 jdk1.7 中并没有开始使用。在 jdk1.8 中才开始大量使用，主要就是我们大量用的 lambda 表达式。
  - 总结：
    - 如果在编译时期解析，那么指令指向的方法就是静态绑定，也就是 private，final，static 和构造方法，也就是上面的 invokestatic 和 invokespecial 指令，这些在编译器已经确定具体指向的方法。而接口和虚方法调用无法找到真正需要调用的方法，因为它可能是定义在子类中的方法，所以这种在运行时期才能明确类型的方法我们成为动态绑定。

- 方法表

  - 针对方法调用动态分派的过程，虚拟机会在类的方法区建立一个虚拟方法表的数据结构(virtual method table,vtable),
  - 针对于 invokeinterface 指令来说，虚拟机会建立一个叫做接口方法表的数据结构(interface method table,itable)

    - 方法表会在类的连接阶段初始化，方法表存储的是该类方法入口的一个映射，比如父类的方法 A 的索引号是 1，方法 B 的索引号是 2。。。
      如果子类继承了父类，但是某个父类的方法没有被子类重写，那么在子类的方法表里边该方法指向的是父类的方法的入口，子类并不会重新生成一个方法，然后让方法表去指向这个生成的，这样做是没有意义的。还有一点，如果子类重写了父类的方法，那么子类这个被重写的方法的索引和父类的该方法的索引是一致。比如父类
      A 的 test 方法被子类 C 重写了，那么子类 C 的 test 方法的索引和父类 A 的 test 方法的索引都是 1（打个比方），这样做的目的是为了快速查找，比如说在子类里边找不到一个方法索引为 1 的方法，那么 jvm 会直接去父类查找方法索引为 1 的方法，不需要重新在父类里边遍历。

## 参考资料

- [HotSpot Oop/Klass 模型](https://blog.csdn.net/x_iya/article/details/78873923)
- [JVM 源码分析之安全点 safepoint](https://www.jianshu.com/p/c79c5e02ebe6)
- [Java | JVM 虚方法调用那些事](https://blog.csdn.net/woshilijiuyi/article/details/81366615)
